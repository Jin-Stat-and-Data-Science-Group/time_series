---
title: "基于ARMA-GARCH模型对AAPL股票的实证分析"
author: '王红红'
date: '2020-01-09'
output:
  bookdown::pdf_document2:
    keep_tex: yes
    toc: false
    latex_engine: xelatex
    md_extensions: +east_asian_line_breaks
    citation_package: natbib
    pandoc_args: ["--listing", "--bibliography=Bibfile", "--filter", "pandoc-crossref"]
  bookdown::html_document2:
    number_sections: true
    seq_numbering: true
    fig_caption: true
    highlight: haddock
    theme: null
    md_extensions: +east_asian_line_breaks
    keep_md: true
    toc: false
    pandoc_args: ["--filter", "pandoc-crossref", "-M", "eqnPrefix="]
  bookdown::word_document2:
    fig_caption: true
    reference_docx: ./style/word-styles-02.docx
    md_extensions: +east_asian_line_breaks
    pandoc_args: ["--filter", "pandoc-crossref"]
css: ./style/markdown.css
bibliography: ./Bibfile.bib
eqnPrefixTemplate: ($$i$$)
link-citations: yes
linkReferences: yes
notice: '@*'
csl: ./style/chinese-gb7714-2005-numeric.csl
autoEqnLabels: true
---


```{r setup, echo=F}
knitr::opts_knit$set(root.dir = getwd())
knitr::opts_chunk$set(echo = FALSE, results = 'hide')
knitr::opts_chunk$set(warning = FALSE, message=FALSE)
options(kableExtra.auto_format = F)
```

```{r prepare}
rm(list=ls())
options(digits=4)
options(scipen=100)
graphics.off()
Sys.setlocale("LC_ALL", "Chinese")
```


# 描述性统计

## 数据准备

```{r include=FALSE}
library(quantmod)   # Load the package
#getSymbols("AAPL",from="2005-01-02", to="2019-12-31")  # Download daily prices of Apple stock from Yahoo,src可以指定数据来源
#write.csv(as.data.frame(AAPL),"./data/AAPL.csv",row.names = T)
AAPL <- read.csv("./data/AAPL.csv")
AAPL <- xts(AAPL[,-1],order.by = as.Date(AAPL$X))
dim(AAPL)  # (dimension): See the size of the downloaded data.
head(AAPL)  # See the first 6 rows of the data
tail(AAPL)   # See the last 6 rows of the data 
  # Plot the daily price and volume
#chartSeries(AAPL)#Not shown giving the same plot with black background.
```

获取的是苹果公司2005年1月2日到2019年12月31日的股票交易数据，有3774个交易日，共有
开盘价、最高价、最低价、收盘价、交易量和调整价6个变量。通过chartSeries函数可以对
股票数据进行可视化。图 \@ref(fig:fig-chartseries) 给出的是调整价与交易量。从图中
可以看出调整价伴随着交易量的减少而减少，大致可分别三个阶段。2009年以前，整体形势
区域良好，股价和交易量都在上升。2009年到2013年期间，股价以及交易量呈现均出下降趋
势，但也有出现不同程度的波动，故总体的下降程度不太明显。2013年之后的阶段是股价和
交易量最少的阶段，两个指标大致保持平稳。

```{r fig-chartseries, eval=T, fig.height=3.0, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "the daily price and volume", dev=c("cairo_pdf",'png'),dev.args=list(family="Microsoft YaHei UI Light")}
plot(AAPL[,5])
```


## 日对数化收益率

```{r}
AAPL.rtn=diff(log(AAPL$AAPL.Adjusted)) # Compute log returns
AAPL.rtn=AAPL.rtn[2:3774]
```

```{r fig-return, eval=T, fig.height=3.0, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "return", dev=c("cairo_pdf",'png'),dev.args=list(family="Microsoft YaHei UI Light")}
plot(AAPL.rtn)
```

图 \@ref(fig:fig-return) 给出的是AAPL股票的对数收益率序列。可以大致判断该序列保持平稳，
同时还表现出波动聚集性。

### 正态性检验

```{r}
library(fBasics) # Load package
AAPL.rtn=ts(AAPL.rtn,start=c(2005,1,2),frequency = 356)
head(AAPL.rtn) #Show the first 6 rows of data
basicStats(AAPL.rtn) #Compute summary statistics
mean(AAPL.rtn)
var(AAPL.rtn)
stdev(AAPL.rtn) # standard deviation
s3=skewness(AAPL.rtn)
T=length(AAPL.rtn) # Sample size
t3=s3/sqrt(6/T) # Skewness test
pp=2*(1-pnorm(t3)) # Compute p-value
s4=kurtosis(AAPL.rtn)
t4=s4/sqrt(24/T) # Kurtosis test
2*(1-pnorm(t4)) # Compute p-value
normalTest(AAPL.rtn,method='jb') # JB-test,has heavy tails
t.test(AAPL.rtn)  # Testing mean return = 0

```

```{r fig1, fig.height=3.0, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "return", dev=c("cairo_pdf","png"),dev.args=list(family="Microsoft YaHei UI Light")}
#可视化
par(mfcol=c(1,2))
par(mar=c(5,4,2,1))
hist(AAPL.rtn,nclass=30,freq = FALSE) 
# Histogram直方图break用于指定分组,freq=false表示根据概率密度而不是频数绘制图形
# 当对象都是标量时,breaks和nclass作业相同
d1=density(AAPL.rtn)  # Obtain density estimate
range(AAPL.rtn)  # Range of 3M returns
x=seq(-0.1974699, 0.1301941,by = ((0.1301941+0.1974699)/(511)))
y1=dnorm(x,mean(AAPL.rtn),stdev(AAPL.rtn)) # 计算正态分布的概率密度
plot(d1$x,d1$y,xlab='rtn',ylab='density',type='l')
lines(x,y1,lty=2) #same mean, same stdev
```

接下来首先对对数收益率序列做描述性统计，计算最大值，最小值等。并计算峰度和偏度，
根据峰度和偏度的统计量$t=\frac{\hat{S}(r)}{\sqrt{6/T}}$和$t=\frac{\hat{K}(r)-3}{\sqrt{24/T}}$
在大样本下分别为服从标准正态分布的性质，可以对该收益率序列的峰度和偏度进行检验。JB统计量
$JB=\frac{\hat{S}^{2}(r)}{6 / T}+\frac{(\hat{K}(r)-3)^{2}}{24 / T}$是
这两个统计量的平方和，将其想加即可利用该统计量进行正态性检验。其中${\hat{S}(r)}$和
${\hat{K}(r)}$分别表示样本偏度和样本峰度。检验结果显示，该序列不服从正
态分布,图 \@ref(fig:fig1) 的可视化部分验证了这一结论。与正态分布相比，该序列的概率
密度曲线呈现出尖峰厚尾性质。最后利用t检验得出该序列均值不为0。

### 白噪声和平稳性检验

```{r}
for(i in 1:2) print(Box.test(AAPL.rtn,lag=i*6))#p-value =2.2e-16,表明一阶差分序列为非白噪声序列
```

在对时间序列构建模型之前，应首先进行白噪声检验，以确定该序列是否包含相关性信息，从而
选择合适的方法进行模型构建。白噪声检验利用$Q(m)=T(T+2) \sum_{t=1}^{m} \frac{\hat{\rho}_{t}^{2}}{T-\ell}$统计量，其中T表示序列长度。该序列近似服从自由度为m
的$\chi^{2}$分布。计算得到Q统计量的p值小于0.05,表明该序列含有相关性信息，需进一步提取。

```{r fig2, fig.height=3.0, fig.width=6.5,out.width="95%", fig.pos="H", fig.cap = "AAPL station test", dev=c("cairo_pdf","png"),dev.args=list(family="Microsoft YaHei UI Light")}
par(mfcol=c(1,2))
acf(AAPL.rtn)
pacf(AAPL.rtn)
library(tseries)
#adf.test(AAPL.rtn)
#library(fUnitRoots)
#adfTest(AAPL.rtn,lag=1,type='c')
```

在确定对数收益率序列中含有相关信息后再进行平稳性检验。图 \@ref(fig:fig2) 中的ACF显示，
自相关图除了4阶自相关系数超过两倍标准差以外，大部分在两倍标准差范围内，说明该序列具有
短期相关性，初步判断该序列具有平稳性。通过自相关图进行平稳性检验具有一定的主观性，所得
结果不准确，接下来用单位根进行检验。结果如表 \@ref(tab:tab3),分别使用DF检验和ADF
检验，DF检验只能用于序列只有一阶自相关的情形，ADF检验适用于高阶自相关，滞后阶数的选择
由图 \@ref(fig:fig2) 中的自相关系数确定，自相关图显示16阶自相关系数显著不为0，故在进
行ADF检验时,设置lag=16。检验结果的p值均小于0.05，也说明该序列有平稳性。

```{r tab3, cache=F, results='markup'}
library(fUnitRoots)
#adfTest(AAPL.rtn,lag=1,type='c')
STATISTIC=c('DF','ADF')
TYPE=c('c','nc','ct')
a=expand.grid(STATISTIC,TYPE)
#adfTest(AAPL.rtn,lag=16,type='c')@test$statistic
test=vector(length = 6);stat=vector(length = 6)
for(i in 1:length(a$Var1)){
    if(a[i,1]=='DF'){
        test[i] = adfTest(AAPL.rtn,lag=1,type=a[i,2])@test$p.value
        stat[i] = adfTest(AAPL.rtn,lag=1,type=a[i,2])@test$statistic
    }
    if(a[i,1]=='ADF'){
        test[i] = adfTest(AAPL.rtn,lag=16,type=a[i,2])@test$p.value
        stat[i] = adfTest(AAPL.rtn,lag=16,type=a[i,2])@test$statistic
    }
}
test=matrix(test,ncol = 2,byrow =T )
stat=matrix(stat,ncol = 2,byrow =T )
value=cbind(stat,test)
unitroot=as.data.frame(value)
dimnames(unitroot)=list(TYPE,c('DF-STATISTIC','ADF-STATISTIC','DF-p.value','ADF-p.value'))

library("kableExtra")
knitr::kable(unitroot, row.names =T, align = c("r", "r", "r", "r"),
             caption="unitroot test",digits = 4,
             longtable = TRUE, booktabs = TRUE, escape = F) %>%
    kable_styling(latex_options = c("striped", "scale_down", "repeat_header", "hold_position"),
                  ## stripe_index = rep(1:5, 4)+rep(c(0,10,20,30), each = 5),
                  repeat_header_text = "(续)")%>%
    kable_styling(full_width = T) %>%
    column_spec(1, width = c("4.5cm"))
```

# 实证分析
## 建立ARMA模型

```{r include=FALSE}
m1=arima(AAPL.rtn,order=c(0,0,2))
m1
#tsdiag(m1)
#plot(m1$residuals)
for(i in 1:4) print(Box.test(m1$residuals,lag=i*10))#p-value
#acf(m1$residuals)
# p1=c(1,m1$coef[1:2]) # set-up the polynomial
# r1=polyroot(p1) # solve the polynomial equation
# r1
# Mod(r1)
# k=2*pi/acos(1.616116/1.832674) # compute length of the period
# k
m2=arima(AAPL.rtn,order=c(2,0,0))
m2
#plot(m2$residuals)
for(i in 1:4) print(Box.test(m2$residuals,lag=i*6))#p-value
library(tseries)
m3=arma(AAPL.rtn,order=c(2,2),include.intercept = F)
m3
#plot(m3$residuals)
for(i in 1:4) print(Box.test(m3$residuals,lag=i*5))#p-value
tratio=m3$coef/sqrt(diag(m3$vcov))
# tratio[1]
# acf(m3$residuals)
# pacf(m3$residuals)
# mu=m3$coef[5]/(1-sum(m3$coef[1:2]))
```

根据ACF和PACF尝试拟合ARIMA(0,0,2)、ARIMA(2,0,0)、ARIMA(2,0,2)三个模型，得到最好模型
是ARIMA(2,0,2)。对ARIMA(0,0,2)模型的残差序列进行Box.test检验，p值小于0.05,表明ARIMA(0,0,2)
模型对苹果公司股票对数收益率序列的相关性信息提取不充分。ARIMA(2,0,0)中残差序列仍不满
足白噪声假设，信息提取不足。ARIMA(2,0,2)中残差序列的p值大于0.05，说明残差序列不具有相关性，
ARIMA(2,0,2)模型对收益率序列的相关性作了较好的描述刻画。
最后通过$\mu=\phi_{0} /\left(1-\phi_{1}-\cdots-\phi_p\right)$计
算得到该只股票的长期收益率为0.06%。

## ARIMA模型检验

### 残差序列正态性检验

```{r}
s3=skewness(m3$residuals[3:length(m3$residuals)])
T=length(m3$residuals[2:length(m3$residuals)]) # Sample size
t3=abs(s3/sqrt(6/T)) # Skewness test
pp=2*(1-pnorm(t3)) # Compute p-value

s4=kurtosis(m3$residuals[3:length(m3$residuals)])
t4=s4/sqrt(24/T) # Kurtosis test
2*(1-pnorm(t4)) # Compute p-value

normalTest(m3$residuals[3:length(m3$residuals)],method='jb') # JB-test,has heavy tails
# #可视化
# hist(m3$residuals,nclass=30,freq = FALSE) 
# d1=density(m3$residuals)  # Obtain density estimate
# range(m3$residuals)  # Range of 3M returns
# x=seq(-0.1947915, 0.1263372,by = ((0.1263372+0.1947915)/(511)))
# y1=dnorm(x,mean(m3$residuals),stdev(m3$residuals)) # 计算正态分布的概率密度
# plot(d1$x,d1$y,xlab='rtn',ylab='density',type='l')
# lines(x,y1,lty=2) #same mean, same stdev
```

对残差进行正态性检验，分布采用JB统计量和图示法进行，结果均显示非正态分布。且
残差序列的偏态性系数`r skewness(m3$residuals[3:length(m3$residuals)])`和峰态系
数`r kurtosis(m3$residuals[3:length(m3$residuals)])`的统计量显示残差序列有左偏
高峰性质，即金融序列常见的尖峰厚尾。


### 残差序列ARCH效应检验
```{r}
library(FinTS)
for(i in 1:5) print(ArchTest(m3$residuals,lag=i))
```

运用FinTS包中的ArchTest函数可以对残差序列进行LM拉格朗日乘子检验，结果显示
残差序列存在ARCH效应。这种效应指的是条件异方差性，表现为均值方差残差平方
序列的相关性，所以可以对均值方程残差序列的平方进行白噪声检验。LM检验类似
于线性回归中的F检验，LM统计量服从自由度为m和T-2m-1的F分布。其中m为最大滞
后阶数。

## 对序列拟合ARIMA-Garch模型

```{r include=FALSE}
# acf(m3$residuals)
# pacf(m3$residuals)
t.test(m3$residuals)
library(fGarch)
m4=garchFit(~arma(2,2)+garch(1,1),data=AAPL.rtn,trace=F,include.mean = F,cond.dist = 'sstd')
summary(m4)
```

对均值方程残差序列的条件异方差性进行描述也就是构建波动率模型。常见的一元波动率模型
包括由Engle(1982)提出的自回归条件异方差模型，由于该模型的待估参数较多，后来Bollerslev
(1986)提出广义自回归异方差模型GARCH。通常情况下，低阶的GARCH模型，如GARCH(1,1)、
GARCH(1,2)、GARCH(2,1)、GARCH(2,2)就足够描述收益率序列的异方差性，大大提高参数估计
效率。

通过t.test函数对残差序列做0均值检验，结果显示残差序列均值为0，所以在估计模型参数时
设置GARCH模型中不再含有常数项。由于前面的正态性检验显示，残差序列不服从正态分布，且左
偏。故设置条件分布分别为有偏学生t分布sstd，有偏正态分布snorm,正态分布来
拟合GARCH模型。结果如表 \@ref(tab:tab4) 所示。

```{r include=FALSE}
m5=garchFit(~arma(2,2)+garch(1,1),data=AAPL.rtn,trace=F,include.mean = F,cond.dist = 'snorm')
summary(m5)
m6=garchFit(~arma(2,2)+garch(1,1),data=AAPL.rtn,trace=F,include.mean = F,cond.dist = 'norm')
summary(m6)
# m7=garchFit(~arma(2,2)+garch(1,2),data=AAPL.rtn,trace=F,include.mean = F,cond.dist = 'sstd')
# summary(m7)
# m8=garchFit(~arma(2,2)+garch(2,2),data=AAPL.rtn,trace=F,include.mean = F,cond.dist = 'sstd')
# summary(m8)
# for(i in 1:4) print(Box.test(m8@residuals,lag=i*5))#p-value
# for(i in 1:4) print(Box.test(m7@residuals,lag=i*5))#p-value
# head(m3$residuals)
```

```{r tab4, cache=F, results='markup'}
colname=c('model1-est','model1-p','model2-est','model2-p','model3-est','model3-p')
# summary(m4)
# str(m4)
# as.numeric(m4@fit$llh);as.numeric(m4@fit$ics[1:2])
rowname=c(dimnames(m4@fit$matcoef)[[1]],'log','AIC','BIC')

value1=c(as.data.frame(m4@fit$matcoef)[,1],as.numeric(m4@fit$llh),as.numeric(m4@fit$ics[1:2]))
value2=c(as.data.frame(m5@fit$matcoef)[,1],NaN,as.numeric(m5@fit$llh),as.numeric(m5@fit$ics[1:2]))
value3=c(as.data.frame(m6@fit$matcoef)[,1],NaN,NaN,as.numeric(m6@fit$llh),as.numeric(m6@fit$ics[1:2]))
P1=c(as.data.frame(m4@fit$matcoef)[,4],rep(NaN,3))
P2=c(as.data.frame(m5@fit$matcoef)[,4],rep(NaN,4))
P3=c(as.data.frame(m6@fit$matcoef)[,4],rep(NaN,5))
value.garch=as.data.frame(cbind(value1,P1,value2,P2,value3,P3))
dimnames(value.garch) <- list(rowname,colname)

library("kableExtra")
knitr::kable(value.garch, row.names =T, align = c("r", "r", "r", "r","r", "r"),
             caption="ARIMA-GARCH models table",digits = 3,
             longtable = TRUE, booktabs = TRUE, escape = F) %>%
    kable_styling(latex_options = c("striped", "scale_down", "repeat_header", "hold_position"),
                  ## stripe_index = rep(1:5, 4)+rep(c(0,10,20,30), each = 5),
                  repeat_header_text = "(续)")%>%
    kable_styling(full_width = T) %>%
    column_spec(1, width = c("1cm","7cm","1.5cm","7cm","1.5cm","7cm","1.5cm"))
```

表 \@ref(tab:tab4) 中的model1指的是ARIMA(2,2)-GARCH(1,1)-sstd,model2对应
ARIMA(2,2)-GARCH(1,1)-snorm,model3对应ARIMA(2,2)-GARCH(1,1)-norm。通过比较可以发现
虽然model1的AIC和BIC最小，但其ar(1)和ma(1)系数在5%的显著性水平下不显著。进一步对残
差序列进行白噪声检验和ARCH效应检验，可以发现该模型的残差序列中仍存在相关性信息。同
时相比model3中基于正态分布的GARCH模型，model2基于偏态正态分布的ARIMA(2,2)-GARCH(1,1)
-snorm对收益率序列的描述更充分，各项系数在5%水平下均显著，说明使用偏态正态分布是合适
的。由此可以判断最优模型是ARIMA(2,2)-GARCH(1,1)-snorm。

$$$$

```{r fig3, fig.height=3.0, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "standardized residual", dev=c("cairo_pdf",'png')}

resi <- residuals(m5,standardize=T)
res <- ts(resi,frequency = 365,start=c(2005,1,4))
plot(res,xlab='date',ylab='sstd.resi',type='l')

```

图 \@ref(fig:fig3) 给出了标准化残差的时序图,除了两三个异常值
以外，标准化残差看起来是正常的。图 \@ref(fig:fig4) 给出了标
准化残差序列及其平方序列的ACF和PACF.除了标准化残差在间隔8有轻
微的自相关外，其余自相关系数和偏自相关系数都显著为0。这些ACF和
PACF确证了拟合模型充分刻画了对数收益率的条件均值和条件方差。图
\@ref(fig:fig5) 给出了模型的拟合波动率序列。如预期那样，从该
序列可以看出苹果公司在2007年开始的经济危机期间受影响，经济危机
期间，波动率较高。图 \@ref(fig:fig6) 给出了95%的点预测区间对
数收益率时序图。除了某些异常值外，大部分收益率在95%的预测区间内
。最后图 \@ref(fig:fig7) 给出了标准化残差序列的qq图，从中可以看
出该序列不服从正态分布并且是左偏的。基于以上分析

```{r fig5, fig.height=3.0, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "volatility", dev=c("cairo_pdf","png"),dev.args=list(family="Microsoft YaHei UI Light")}
v1 <- volatility(m5)
vol=ts(v1,frequency = 365,start=c(2005,1,4))
plot(vol,xlab='date',ylab='volatility',type='l')
```

```{r fig4,  fig.height=6, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "residual acf-pacf", dev=c("cairo_pdf","png"),dev.args=list(family="Microsoft YaHei UI Light")}
par(mfcol=c(2,2))
acf(res,lag=24)
pacf(res,lag=24)
acf(res^2,lag=24)
pacf(res^2,lag=24)
```

```{r fig6, fig.height=3.0, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "series", dev=c("cairo_pdf","png"),dev.args=list(family="Microsoft YaHei UI Light")}
par(mfcol=c(1,1))
plot(m5,which=3)
#library(fUnitRoots)
#adfTest(AAPL.rtn,lag=1,type='c')
```


```{r fig7, fig.height=3.0, fig.width=6.5,out.width="1.0\\textwidth", fig.pos="H", fig.cap = "qq picture", dev=c("cairo_pdf","png")}
plot(m5,which=13)
```

# EGARCH模型拟合
以上GARCH模型在拟合金融序列时，不能对杠杆效应进行有效描述。市场上正效应和
负效应对波动率的影响是不同的，所以接下来尝试使用EGARCH(1,1)
模型对对数收益率序列进行拟合。

首先给出常用EGARCH的模型形式：

$$\ln \left(\sigma_{t}^{2}\right)=\alpha_{0}+\sum_{i=1}^{m} \alpha_{i} \frac{\left|a_{t-i}\right|+\gamma_{i} a_{t-i}}{\sigma_{t-i}}+\sum_{j=1}^{s} \beta_{j} \ln \left(\sigma_{t-j}^{2}\right)$$

```{r echo=TRUE}
library(rugarch)
egarch.spec1 = ugarchspec(variance.model = list(model="eGARCH",garchOrder=c(1,1)),    
                         mean.model = list(armaOrder=c(2,2),include.mean = F),
                         distribution.model = "snorm")  
egarch.fit1 = ugarchfit(spec=egarch.spec1, data=AAPL.rtn)

coef(egarch.fit1)   #估计的系数  
vcov(egarch.fit1)#参数估计量的协方差矩阵  
infocriteria(egarch.fit1) #常用信息量列表  
newsimpact(egarch.fit1) #计算信息冲击曲线  
signbias(egarch.fit1) #Engle - Ng符号偏差检验  
fitted(egarch.fit1)   #获得拟合的数据序列  
head(residuals(egarch.fit1)) #获得残差  
uncvariance(egarch.fit1) #无条件的（长期）方差  
uncmean(egarch.fit1)  #无条件的（长期）均值 

# head(m3$residuals/egarch.fit1@fit$sigma)
par(mfcol=c(2,1))
plot(egarch.fit1@fit$sigma,type='l')
plot(v1,type='l')
```

# VaR计算

常见的风险度量有风险值VaR和期望损失ES两种。VaR是损失变量的(1-p)分位数，表示
在一定的时间段内，金融头寸持有者的潜在损失小于等于VaR的概率为1-p。也就是说，
VaR是右尾概率为p的分位数。实际上并不能真正描述损失随机变量的实际行为，给定
两个随机变量，他们有相同的概率为p的VaR，但是他们的尾部行为可能存在差异，因为
VaR只是一定概率的分位数，而损失随机变量的分布不一定相同。所以VaR并不是完美的
风险度量，所以进一步使用期望损失进行测算。ES是VaR的期望值，利用损失分布信息
可以描述右尾部行为。

对以上的最优模型ARIMA(2,2)-GARCH(1,1)-snorm分别计算风险值VaR和期望损失ES。

```{r}
pre=predict(m5,3)

prob=c(0.95,0.99,0.999)
VaR=qsnorm(p=prob,mean=pre$meanForecast,sd=pre$meanError,xi=0.979)

g1=function(p){
  qsnorm(p,mean=pre$meanForecast[1],sd=pre$meanError[1],xi=0.979)
}
g2=function(p){
  qsnorm(p,mean=pre$meanForecast[2],sd=pre$meanError[2],xi=0.979)
}
g3=function(p){
  qsnorm(p,mean=pre$meanForecast[3],sd=pre$meanError[3],xi=0.979)
}
ES=c()
ES[1]=integrate(g1,prob[1],1)
ES[2]=integrate(g2,prob[2],1)
ES[3]=integrate(g3,prob[3],1)
ES=c(ES[[1]]/(1-0.95),ES[[2]]/(1-0.99),ES[[3]]/(1-0.999))
tt=cbind(prob,VaR,ES)
as.data.frame(tt)
```
